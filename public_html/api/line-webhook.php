<?php
// /home/bot.dailymu.com/public_html/api/line-webhook.php

require_once __DIR__ . '/../../private/vendor/autoload.php';
require_once __DIR__ . '/../../private/src/Config.php';
require_once __DIR__ . '/../../private/src/FortuneHandler.php';
require_once __DIR__ . '/../../private/src/UserHandler.php';

use GuzzleHttp\Client;
use LINE\Clients\MessagingApi\Api\MessagingApiApi;
use LINE\Clients\MessagingApi\Configuration;
use LINE\Clients\MessagingApi\Model\TextMessage;
use LINE\Clients\MessagingApi\Model\ReplyMessageRequest;
use LINE\Constants\MessageType;
use LINE\Parser\SignatureValidator;

class LineWebhook {
    private MessagingApiApi $messagingApi;
    private FortuneHandler $fortune;
    private UserHandler $user;

    public function __construct() {
        // Initialize LINE API client
        $client = new Client();
        $config = new Configuration();
        $config->setAccessToken(Config::LINE_CHANNEL_ACCESS_TOKEN);
        
        $this->messagingApi = new MessagingApiApi(
            client: $client,
            config: $config
        );

        // Initialize handlers
        $this->fortune = new FortuneHandler();
        $this->user = new UserHandler();
    }

    public function handleRequest() {
        try {
            // Debug: Log all headers
            $headers = getallheaders();
            error_log("All headers: " . json_encode($headers));

            // Get signature from different possible sources
            $signature = $headers['X-Line-Signature'] 
                     ?? $headers['x-line-signature']
                     ?? $_SERVER['HTTP_X_LINE_SIGNATURE']
                     ?? '';

            error_log("Signature found: " . $signature);

            // Get request body
            $body = file_get_contents("php://input");
            error_log("Request body: " . $body);

            // For GET requests (webhook verification)
            if ($_SERVER['REQUEST_METHOD'] === 'GET') {
                return $this->handleVerification();
            }

            // Skip signature validation for empty requests
            if (empty($body)) {
                return $this->handleVerification();
            }

            // Validate signature if we have both body and signature
            if (!empty($signature)) {
                if (!SignatureValidator::validateSignature($body, Config::LINE_CHANNEL_SECRET, $signature)) {
                    error_log("Invalid signature validation");
                    http_response_code(400);
                    return ['error' => 'Invalid signature validation'];
                }
            } else {
                error_log("No signature found for non-empty request");
                return $this->handleVerification();
            }

            // Parse webhook body
            $events = json_decode($body, true)['events'] ?? [];
            $this->processEvents($events);

            return ['status' => 'ok'];

        } catch (Exception $e) {
            error_log("Error in webhook: " . $e->getMessage());
            http_response_code(500);
            return [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ];
        }
    }

    private function handleVerification() {
        return [
            'status' => 'ready',
            'timestamp' => date('Y-m-d H:i:s'),
            'message' => 'Webhook URL verified'
        ];
    }

    private function processEvents(array $events) {
        error_log("Processing events: " . json_encode($events));
        
        foreach ($events as $event) {
            if ($event['type'] === 'message' && $event['message']['type'] === 'text') {
                $this->handleMessage($event);
            }
        }
    }

    private function handleMessage(array $event) {
        try {
            error_log("Handling message event: " . json_encode($event));

            $userId = $event['source']['userId'];
            $message = $event['message']['text'];
            $replyToken = $event['replyToken'];

            // Get or create user
            $user = $this->user->getOrCreateUser('line', $userId);

            // Process message
            $reply = $this->processFortuneCommand($message, $user['id']);

            // Create and send reply
            $textMessage = (new TextMessage())
                ->setType(MessageType::TEXT)
                ->setText($reply);

            $request = (new ReplyMessageRequest())
                ->setReplyToken($replyToken)
                ->setMessages([$textMessage]);

            $this->messagingApi->replyMessage($request);
            error_log("Message sent successfully");

        } catch (Exception $e) {
            error_log("Error in handleMessage: " . $e->getMessage());
        }
    }

    private function processFortuneCommand($message, $userId) {
        try {
            // ‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏£‡∏≤‡∏¢‡∏ß‡∏±‡∏ô
            if (strpos($message, '‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ') !== false || 
                strpos($message, '‡∏î‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ') !== false) {
                $fortune = $this->fortune->getDailyFortune($userId);
                return $this->formatDailyFortune($fortune);
            }

            // ‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏£‡∏≤‡∏®‡∏µ
            if (strpos($message, '‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏£‡∏≤‡∏®‡∏µ') !== false) {
                $zodiac = $this->extractZodiac($message);
                if ($zodiac) {
                    $fortune = $this->fortune->getZodiacFortune($userId, $zodiac);
                    return $this->formatZodiacFortune($fortune);
                }
                return "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏£‡∏≤‡∏®‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏î‡∏ß‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÄ‡∏ä‡πà‡∏ô '‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏£‡∏≤‡∏®‡∏µ‡∏Å‡∏±‡∏ô‡∏¢‡πå' üåü";
            }

            // ‡∏î‡∏π‡∏î‡∏ß‡∏á‡πÑ‡∏û‡πà
            if (strpos($message, '‡∏î‡∏π‡πÑ‡∏û‡πà') !== false || 
                strpos($message, '‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏û‡πà') !== false) {
                $fortune = $this->fortune->getTarotFortune($userId, $message);
                return $this->formatTarotFortune($fortune);
            }

            // ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á
            return "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏î‡∏π‡∏î‡∏ß‡∏á‡πÑ‡∏î‡πâ‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ:\n" .
                   "1. ‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô\n" .
                   "2. ‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏£‡∏≤‡∏®‡∏µ...' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏ï‡∏≤‡∏°‡∏£‡∏≤‡∏®‡∏µ\n" .
                   "3. ‡∏û‡∏¥‡∏°‡∏û‡πå '‡∏î‡∏π‡πÑ‡∏û‡πà' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏î‡∏ß‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÑ‡∏û‡πà‡∏ó‡∏≤‡πÇ‡∏£‡∏ï‡πå\n" .
                   "‚ú® ‡∏°‡∏¥‡∏£‡∏∞‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏Ñ‡πà‡∏∞ ‚ú®";

        } catch (Exception $e) {
            error_log("Error in processFortuneCommand: " . $e->getMessage());
            return "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏£‡∏∞‡∏ö‡∏ö‡∏Ç‡∏±‡∏î‡∏Ç‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏∞‡∏Ñ‡∏∞ üôè";
        }
    }

    private function extractZodiac($message) {
        $zodiacMap = [
            '‡∏£‡∏≤‡∏®‡∏µ‡πÄ‡∏°‡∏©', '‡∏£‡∏≤‡∏®‡∏µ‡∏û‡∏§‡∏©‡∏†', '‡∏£‡∏≤‡∏®‡∏µ‡πÄ‡∏°‡∏ñ‡∏∏‡∏ô', '‡∏£‡∏≤‡∏®‡∏µ‡∏Å‡∏£‡∏Å‡∏é',
            '‡∏£‡∏≤‡∏®‡∏µ‡∏™‡∏¥‡∏á‡∏´‡πå', '‡∏£‡∏≤‡∏®‡∏µ‡∏Å‡∏±‡∏ô‡∏¢‡πå', '‡∏£‡∏≤‡∏®‡∏µ‡∏ï‡∏∏‡∏•‡∏¢‡πå', '‡∏£‡∏≤‡∏®‡∏µ‡∏û‡∏¥‡∏à‡∏¥‡∏Å',
            '‡∏£‡∏≤‡∏®‡∏µ‡∏ò‡∏ô‡∏π', '‡∏£‡∏≤‡∏®‡∏µ‡∏°‡∏±‡∏á‡∏Å‡∏£', '‡∏£‡∏≤‡∏®‡∏µ‡∏Å‡∏∏‡∏°‡∏†‡πå', '‡∏£‡∏≤‡∏®‡∏µ‡∏°‡∏µ‡∏ô'
        ];

        foreach ($zodiacMap as $zodiac) {
            if (strpos($message, $zodiac) !== false) {
                return $zodiac;
            }
        }
        return null;
    }

    private function formatDailyFortune($fortune) {
        return "üîÆ ‡∏î‡∏ß‡∏á‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì\n\n" .
               "üìù ‡∏î‡∏ß‡∏á‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏°: {$fortune['overall']}\n\n" .
               "‚ù§Ô∏è ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å: {$fortune['aspects']['love']}\n" .
               "üíº ‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô: {$fortune['aspects']['work']}\n" .
               "üí∞ ‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô: {$fortune['aspects']['finance']}\n" .
               "üè• ‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û: {$fortune['aspects']['health']}\n\n" .
               "üé≤ ‡πÄ‡∏•‡∏Ç‡∏ô‡∏≥‡πÇ‡∏ä‡∏Ñ: {$fortune['lucky']['numbers']}\n" .
               "üé® ‡∏™‡∏µ‡∏°‡∏á‡∏Ñ‡∏•: " . implode(", ", array_keys($fortune['lucky']['colors'])) . "\n\n" .
               "üí´ ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: {$fortune['advice']}";
    }

    private function formatZodiacFortune($fortune) {
        return "üåü ‡∏î‡∏ß‡∏á‡∏ä‡∏∞‡∏ï‡∏≤‡∏£‡∏≤‡∏®‡∏µ {$fortune['zodiac']}\n\n" .
               "‡∏ò‡∏≤‡∏ï‡∏∏: {$fortune['element']}\n" .
               "{$fortune['description']}\n\n" .
               "‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏î‡∏ß‡∏á:\n" .
               "üåû ‡∏î‡∏ß‡∏á‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏°: {$fortune['readings']['overall']}\n" .
               "‚ù§Ô∏è ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å: {$fortune['readings']['love']}\n" .
               "üíº ‡∏Å‡∏≤‡∏£‡∏á‡∏≤‡∏ô: {$fortune['readings']['work']}\n" .
               "üí∞ ‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô: {$fortune['readings']['finance']}\n" .
               "üè• ‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û: {$fortune['readings']['health']}\n\n" .
               "üé≤ ‡πÄ‡∏•‡∏Ç‡∏°‡∏á‡∏Ñ‡∏•: " . implode(", ", $fortune['lucky']['numbers']) . "\n" .
               "üé® ‡∏™‡∏µ‡∏°‡∏á‡∏Ñ‡∏•: " . implode(", ", $fortune['lucky']['colors']) . "\n\n" .
               "‚≠ê ‡∏≠‡∏¥‡∏ó‡∏ò‡∏¥‡∏û‡∏•‡∏î‡∏ß‡∏á‡∏î‡∏≤‡∏ß: {$fortune['planetary']}";
    }

    private function formatTarotFortune($fortune) {
        $message = "üé¥ ‡πÑ‡∏û‡πà‡∏ó‡∏≤‡πÇ‡∏£‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì\n\n";
        foreach ($fortune['cards'] as $card) {
            $reversed = $card['card']['is_reversed'] ? "(‡∏Ñ‡∏ß‡πà‡∏≥)" : "(‡∏´‡∏á‡∏≤‡∏¢)";
            $message .= "üÉè {$card['position']}\n";
            $message .= "‡πÑ‡∏û‡πà: {$card['card']['name']} {$reversed}\n";
            $message .= "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢: {$card['card']['meaning']}\n\n";
        }
        $message .= "‚ú® ‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå:\n{$fortune['overall_meaning']}";
        return $message;
    }
}

// Handle webhook
$webhook = new LineWebhook();
$result = $webhook->handleRequest();
echo json_encode($result);